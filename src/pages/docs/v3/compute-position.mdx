---
navigationLabel: computePosition
order: 2
---

# computePosition

The `computePosition` function is the heart of Popper. It computes the necessary
coordinates, and provides useful data, to position the popper element next to a
given reference element.

```js
// umd
const { computePosition } = PopperDOM;

// esm
import { computePosition } from '@popperjs/dom';
```

It accepts three arguments:

```js
computePosition(reference, popper, {
  // options
});
```

The `popper` is the floating element that gets positioned relative to the
`reference` element.

It's async, so it returns a `Promise`.

## Usage

```js
computePosition(reference, popper, {
  // options
  placement: 'right',
}).then((data) => {
  const { x, y, placement, strategy, modifiersData } = data;
  // Do things with the data here...
});
```

`x` and `y` are numbers which represent the positioning coordinates of the
popper element relative to its `offsetParent`.

**Note:** always ensure the popper element has a strategy applied (i.e. CSS
`position: absolute`) _before_ calling `computePosition`.

## Return value

`computePosition` resolves with the following data:

```flow
type ComputePositionReturn = {|
  ...Coords,
  placement: Placement, // default: "bottom"
  strategy: PositioningStrategy, // default: "absolute"
  // Data provided by modifiers, if any.
  modifiersData: {
    [key: string]: any,
  },
|};

// The positioning coordinates to apply to the popper element.
type Coords = {|
  x: number,
  y: number,
|};

// The initial (or preferred) placement of the popper element.
type Placement =
  | 'top'
  | 'top-start'
  | 'top-end'
  | 'right'
  | 'right-start'
  | 'right-end'
  | 'bottom'
  | 'bottom-start'
  | 'bottom-end'
  | 'left'
  | 'left-start'
  | 'left-end';

// CSS `position` property.
type PositioningStrategy = 'absolute' | 'fixed';
```

## Options

Options are passed as a third argument to `computePosition()`.

```flow
type Options = {
  // The initial (or preferred) placement.
  placement: Placement,
  // CSS position property to use.
  strategy: PositioningStrategy,
  // Middleware which modify the resolved data.
  modifiers: Array<Modifier>,
  // An object containing methods to calculate element sizes and offsets.
  // The DOM platform is used on the web.
  platform: Platform,
};
```

## Updating

If you need to update the position again later, or in an event listener, you'll
probably want to wrap it in a function:

```js
async function update() {
  const { x, y } = await computePosition(reference, popper, {
    placement: 'right',
  });

  Object.assign(popper.style, {
    left: `${x}px`,
    top: `${x}px`,
  });
}

// Initial update.
update();

// Update on scroll or resize of the window.
addEventListener('scroll', update);
addEventListener('resize', update);
```

### scrollParent

If your reference element is contained within a scrolling container, but your
popper element not, then you'll also need a `scroll` listener the container,
too, in addition to the `window`.

You can use the `listScrollParents` util which will return all the scrolling
parents:

```js
import { listScrollParents } from '@popperjs/dom';

async function update() {
  // ...
}

[...listScrollParents(reference), ...listScrollParents(popper)].forEach(
  (scrollParent) => {
    scrollParent.addEventListener('scroll', update);
    scrollParent.addEventListener('resize', update);
  }
);
```

Other cases in which the element's position should be updated include the
reference or popper elements changing size or location (e.g. layout changes).
